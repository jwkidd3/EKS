apiVersion: batch/v1
kind: Job
metadata:
  name: userX-postgres-restore
  namespace: userX-namespace
  labels:
    app: postgres-restore
    owner: userX
spec:
  template:
    metadata:
      labels:
        app: postgres-restore
        owner: userX
    spec:
      restartPolicy: Never
      containers:
      - name: postgres-restore
        image: postgres:13-alpine
        command: ['sh', '-c']
        args:
        - |
          echo "Starting PostgreSQL restore job for userX..."

          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL service..."
          until pg_isready -h userX-postgres-service -p 5432 -U userX; do
            echo "Waiting for PostgreSQL..."
            sleep 5
          done

          echo "PostgreSQL is ready. Starting restore process..."

          # Create sample backup data if it doesn't exist
          if [ ! -f /backup/sample_backup.sql ]; then
            echo "Creating sample backup data..."
            cat > /backup/sample_backup.sql << 'EOF'
          -- Sample backup data for userX
          CREATE TABLE IF NOT EXISTS users (
              id SERIAL PRIMARY KEY,
              username VARCHAR(50) UNIQUE NOT NULL,
              email VARCHAR(100) UNIQUE NOT NULL,
              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          CREATE TABLE IF NOT EXISTS orders (
              id SERIAL PRIMARY KEY,
              user_id INTEGER REFERENCES users(id),
              product_name VARCHAR(100) NOT NULL,
              quantity INTEGER NOT NULL,
              price DECIMAL(10,2) NOT NULL,
              order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          -- Insert sample data
          INSERT INTO users (username, email) VALUES
              ('userX_admin', 'admin@userX.com'),
              ('userX_test', 'test@userX.com'),
              ('userX_demo', 'demo@userX.com')
          ON CONFLICT (username) DO NOTHING;

          INSERT INTO orders (user_id, product_name, quantity, price) VALUES
              (1, 'Sample Product 1', 2, 19.99),
              (1, 'Sample Product 2', 1, 29.99),
              (2, 'Test Product', 3, 9.99),
              (3, 'Demo Product', 1, 49.99)
          ON CONFLICT DO NOTHING;

          -- Create indexes
          CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
          CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
          CREATE INDEX IF NOT EXISTS idx_orders_date ON orders(order_date);
          EOF
          fi

          # Perform the restore
          echo "Restoring database from backup..."
          PGPASSWORD=password123 psql -h userX-postgres-service -U userX -d userX_database -f /backup/sample_backup.sql

          if [ $? -eq 0 ]; then
            echo "Database restore completed successfully!"

            # Verify the restore
            echo "Verifying restored data..."

            echo "Users table:"
            PGPASSWORD=password123 psql -h userX-postgres-service -U userX -d userX_database -c "SELECT * FROM users;"

            echo "Orders table:"
            PGPASSWORD=password123 psql -h userX-postgres-service -U userX -d userX_database -c "SELECT o.id, u.username, o.product_name, o.quantity, o.price, o.order_date FROM orders o JOIN users u ON o.user_id = u.id;"

            echo "Table counts:"
            PGPASSWORD=password123 psql -h userX-postgres-service -U userX -d userX_database -c "SELECT 'users' as table_name, count(*) as row_count FROM users UNION SELECT 'orders', count(*) FROM orders;"

            # Create a backup verification file
            echo "$(date): Restore completed successfully for userX" > /backup/restore_completed.log
            echo "Tables restored: users, orders" >> /backup/restore_completed.log
            echo "Restore job completed at: $(date)" >> /backup/restore_completed.log

          else
            echo "Database restore failed!"
            exit 1
          fi
        env:
        - name: PGPASSWORD
          value: password123
        - name: USER_PREFIX
          value: "userX"
        volumeMounts:
        - name: backup-storage
          mountPath: /backup
        - name: restore-scripts
          mountPath: /scripts
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
      volumes:
      - name: backup-storage
        persistentVolumeClaim:
          claimName: userX-postgres-backup
      - name: restore-scripts
        configMap:
          name: userX-restore-scripts
          defaultMode: 0755
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: userX-restore-scripts
  namespace: userX-namespace
  labels:
    app: postgres-restore
    owner: userX
data:
  create_backup.sh: |
    #!/bin/bash
    echo "Creating backup for userX database..."

    # Create backup directory
    mkdir -p /backup/$(date +%Y-%m-%d)

    # Create full database backup
    PGPASSWORD=password123 pg_dump -h userX-postgres-service -U userX -d userX_database > /backup/$(date +%Y-%m-%d)/full_backup_$(date +%H-%M-%S).sql

    # Create schema-only backup
    PGPASSWORD=password123 pg_dump -h userX-postgres-service -U userX -d userX_database --schema-only > /backup/$(date +%Y-%m-%d)/schema_backup_$(date +%H-%M-%S).sql

    # Create data-only backup
    PGPASSWORD=password123 pg_dump -h userX-postgres-service -U userX -d userX_database --data-only > /backup/$(date +%Y-%m-%d)/data_backup_$(date +%H-%M-%S).sql

    echo "Backup completed!"
    ls -la /backup/$(date +%Y-%m-%d)/

  cleanup_old_backups.sh: |
    #!/bin/bash
    echo "Cleaning up old backups for userX..."

    # Remove backups older than 7 days
    find /backup -name "*.sql" -mtime +7 -delete
    find /backup -type d -empty -delete

    echo "Cleanup completed!"
    df -h /backup

  verify_backup.sh: |
    #!/bin/bash
    echo "Verifying backup integrity for userX..."

    # Check if backup file exists and is not empty
    LATEST_BACKUP=$(find /backup -name "full_backup_*.sql" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)

    if [ -n "$LATEST_BACKUP" ] && [ -s "$LATEST_BACKUP" ]; then
      echo "Latest backup found: $LATEST_BACKUP"
      echo "File size: $(du -h "$LATEST_BACKUP" | cut -f1)"

      # Basic syntax check
      if grep -q "PostgreSQL database dump" "$LATEST_BACKUP"; then
        echo "Backup file appears to be valid PostgreSQL dump"
        echo "Backup verification successful!"
      else
        echo "Backup file does not appear to be a valid PostgreSQL dump"
        exit 1
      fi
    else
      echo "No valid backup found!"
      exit 1
    fi
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: userX-postgres-backup-cron
  namespace: userX-namespace
  labels:
    app: postgres-backup
    owner: userX
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: postgres-backup-cron
            owner: userX
        spec:
          restartPolicy: OnFailure
          containers:
          - name: postgres-backup
            image: postgres:13-alpine
            command: ["/scripts/create_backup.sh"]
            env:
            - name: PGPASSWORD
              value: password123
            - name: USER_PREFIX
              value: "userX"
            volumeMounts:
            - name: backup-storage
              mountPath: /backup
            - name: restore-scripts
              mountPath: /scripts
            resources:
              requests:
                memory: "64Mi"
                cpu: "50m"
              limits:
                memory: "128Mi"
                cpu: "100m"
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: userX-postgres-backup
          - name: restore-scripts
            configMap:
              name: userX-restore-scripts
              defaultMode: 0755